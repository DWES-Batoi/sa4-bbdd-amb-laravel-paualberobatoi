# 4. üì¶ Repository i controlador per a equips

En aquesta part volem que entengueu **qu√® estem fent** quan afegim:

- una **interface** (`BaseRepository`)
- un **repository** (`EquipRepository`)
- un **service** (`EquipService`)
- i el registre al **ServiceProvider**

Ho separem en dos blocs:

1. Explicaci√≥ **conceptual** (sense Laravel).  
2. Aplicaci√≥ **concreta a la pr√†ctica** del projecte.

---

## 1Ô∏è‚É£ Idea general: qu√® s√≥n Repository, Interface, Service i ServiceProvider?

### üéØ Quin problema intentem resoldre?

El flux ‚Äúsimple‚Äù seria:

```php
class EquipController extends Controller {
    public function index() {
        $equips = Equip::all();
        // m√©s l√≤gica...
    }

    public function store(Request $request) {
        Equip::create($request->all());
        // m√©s coses...
    }
}
```

Aix√≤, en un projecte xicotet, **funciona**. 
Per√≤ quan el projecte creix:

- El controller acaba amb **moltes l√≠nies**. 
- Barregem:
  - HTTP (peticions/respostes),
  - l√≤gica de negoci,
  - acc√©s a base de dades (Eloquent/SQL).

I tot aix√≤ barrejat en un √∫nic fitxer es fa:

- dif√≠cil de llegir, 
- dif√≠cil de provar, 
- dif√≠cil de mantindre.

### üß± Soluci√≥: separar responsabilitats

Afegim capes intermitges:

```text
Controller ‚Üí Service ‚Üí Repository ‚Üí Model (Eloquent) ‚Üí BBDD
```

- El **Controller**:
  - rep la petici√≥ (GET/POST/PUT/DELETE),
  - demana al *service* que fa√ßa la feina,
  - envia les dades a la vista o redirigeix.

- El **Service**:
  - cont√© la **l√≤gica de negoci**:
    - ‚Äúqu√® s‚Äôha de fer‚Äù amb les dades,
    - regles, comprovacions, etc.
  - utilitza un *repository* per accedir a la BBDD.

- El **Repository**:
  - √©s el que sap **com** es parla amb la BBDD (Eloquent).
  - concentra les consultes per a un model concret (`Equip` en el nostre cas).

---

### üß© Qu√® √©s una *Interface* (`BaseRepository`)?

Una **interface** √©s un **contracte**: diu quins m√®todes ha de tindre una classe, per√≤ no diu el codi.

Exemple senzill:

```php
interface Animal {
    public function ferSo();
}
```

Qualsevol classe que implemente `Animal` haur√† de tindre un m√®tode `ferSo()`:

```php
class Gos implements Animal {
    public function ferSo() { echo "Bup!"; }
}

class Gat implements Animal {
    public function ferSo() { echo "Miau!"; }
}
```

El codi que rep un `Animal` **no sap** si √©s gos o gat, per√≤ sap que pot cridar `ferSo()`.

En el nostre cas:

```php
interface BaseRepository {
    public function getAll();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}
```

Tradu√Øt:

> Qualsevol *repository* que implemente `BaseRepository`
> ha de tindre almenys aquests m√®todes: `getAll`, `find`, `create`, `update`, `delete`.

Encara **no hi ha cap consulta Eloquent** ac√≠, nom√©s la forma dels m√®todes.

---

### üì¶ Qu√® √©s un *Repository* (`EquipRepository`)?

El **repository** √©s qui s‚Äôencarrega d‚Äôanar a la BBDD per a un model concret.

Per exemple, per a `Equip`:

```php
class EquipRepository implements BaseRepository {
    public function getAll() {
        return Equip::all();
    }

    public function find($id) {
        return Equip::findOrFail($id);
    }

    public function create(array $data) {
        return Equip::create($data);
    }

    public function update($id, array $data) {
        $equip = Equip::findOrFail($id);
        $equip->update($data);
        return $equip;
    }

    public function delete($id) {
        return Equip::destroy($id);
    }
}
```

Ac√≠ **s√≠** tenim codi d‚ÄôEloquent:

- `Equip::all()` 
- `Equip::findOrFail($id)` 
- `Equip::create($data)` 
- `$equip->update($data)` 
- `Equip::destroy($id)`

Si dem√† canvies Eloquent per una API externa o per SQL ‚Äúa p√®l‚Äù, el lloc on tocar quasi sempre ser√† el *repository*, no tota l‚Äôaplicaci√≥.

---

### üß† Qu√® √©s un *Service* (`EquipService`)?

El **service** √©s on posem la **l√≤gica de negoci** d‚Äôun domini concret (equips, estadis, comandes, etc.).

- No tracta amb HTTP directament. 
- No parla directament amb Eloquent. 
- Parla amb el **repository**.

Exemple:

```php
class EquipService {
    public function __construct(private EquipRepository $repo) {}

    public function llistar() {
        return $this->repo->getAll();
    }

    public function trobar($id){
        return $this->repo->find($id);
    }

    public function guardar(array $data) {
        // Ac√≠ podr√≠em fer comprovacions abans de guardar
        return $this->repo->create($data);
    }

    public function actualitzar($id, array $data) {
        return $this->repo->update($id, $data);
    }

    public function eliminar($id) {
        return $this->repo->delete($id);
    }
}
```

El **controller** li demana coses al *service*:

- ‚ÄúLlista‚Äôm els equips‚Äù 
- ‚ÄúGuarda aquest equip nou‚Äù 
- ‚ÄúActualitza aquest equip‚Äù 
- ‚ÄúEsborra‚Äôl‚Äù

El *service* decideix com fer-ho i utilitza el *repository*.

---

### üîå Qu√® √©s un *ServiceProvider* (registrar el repository)?

Laravel t√© un ‚Äúcontenidor‚Äù intern que s‚Äôencarrega de crear objectes i injectar-los als constructors.

Quan escrius:

```php
public function __construct(BaseRepository $repo)
```

Laravel es pregunta:

> ‚ÄúQuina classe concreta he de crear per a omplir aquest `BaseRepository`?‚Äù

Aix√≤ li ho indiquem en un **ServiceProvider**, per exemple a `App\Providers\AppServiceProvider`:

```php
use App\Repositories\BaseRepository;
use App\Repositories\EquipRepository;

public function register(): void
{
    $this->app->bind(BaseRepository::class, EquipRepository::class);
}
```

Traducci√≥:

> ‚ÄúQuan alg√∫ em demane un `BaseRepository`, jo li done un `EquipRepository`.‚Äù

Aix√≤ ens permet injectar la **interface** `BaseRepository` al `EquipService`, 
i Laravel ja s‚Äôencarrega d‚Äôinjectar-li un `EquipRepository`.

---

## 2Ô∏è‚É£ Aplicaci√≥ concreta a la pr√†ctica

Ara apliquem tot aix√≤ al nostre projecte de **futbol femen√≠**.

El que volem fer √©s:

1. **Crear Interface** ‚Üí `BaseRepository` 
2. **Crear Repository** ‚Üí `EquipRepository` 
3. **Registrar Repository** ‚Üí al `ServiceProvider` 
4. **Crear Service** ‚Üí `EquipService` 
5. Fer que el `EquipController` utilitze el **service**.

---

### 4. üì¶ Repository i controlador per a equips

#### 4.1. Crear Interface: `BaseRepository`

üìÑ `app/Repositories/BaseRepository.php`

```php
<?php

namespace App\Repositories;

interface BaseRepository {
    public function getAll();
    public function find($id);
    public function create(array $data);
    public function update($id, array $data);
    public function delete($id);
}
```

Aix√≤ √©s el contracte que despr√©s implementar√† `EquipRepository`.

---

#### 4.2. Crear Repository: `EquipRepository`

üìÑ `app/Repositories/EquipRepository.php`

```php
<?php

namespace App\Repositories;

use App\Models\Equip;

class EquipRepository implements BaseRepository {
    public function getAll() {
        return Equip::all();
    }

    public function find($id) {
        return Equip::findOrFail($id);
    }

    public function create(array $data) {
        return Equip::create($data);
    }

    public function update($id, array $data) {
        $equip = Equip::findOrFail($id);
        $equip->update($data);
        return $equip;
    }

    public function delete($id) {
        return Equip::destroy($id);
    }
}
```

Ara tot l‚Äôacc√©s a la taula `equips` est√† concentrat ac√≠.

---

#### 4.3. Registrar Repository: `AppServiceProvider`

üìÑ `app/Providers/AppServiceProvider.php`

Afegim al principi:

```php
use App\Repositories\BaseRepository;
use App\Repositories\EquipRepository;
```

I dins del m√®tode `register()`:

```php
public function register(): void
{
    $this->app->bind(BaseRepository::class, EquipRepository::class);
}
```

A partir d‚Äôara, quan el contenidor de Laravel veja que algun lloc demana un `BaseRepository`, instanciar√† un `EquipRepository`.

---

### 5. üß† Crear Service: `EquipService`

Ara creem el service d‚Äôequips.

üìÑ `app/Services/EquipService.php`

```php
<?php

namespace App\Services;

use App\Repositories\BaseRepository;

class EquipService {
    public function __construct(private BaseRepository $repo) {}

    public function llistar() {
        return $this->repo->getAll();
    }

    public function trobar($id){
        return $this->repo->find($id);
    }

    public function guardar(array $data) {
        return $this->repo->create($data);
    }

    public function actualitzar($id, array $data) {
        return $this->repo->update($id, $data);
    }

    public function eliminar($id) {
        return $this->repo->delete($id);
    }
}
```

Ac√≠ el `EquipService` **no sap** que hi ha un `EquipRepository` concret. 
Nom√©s sap que t√© un `BaseRepository` que pot fer `getAll`, `find`, `create`, `update`, `delete`.

Gr√†cies al `bind` del ServiceProvider, Laravel li injectar√† un `EquipRepository`.

---

### 5.1. Fer servir el Service des del `EquipController`

Finalment, fem que el controlador utilitze el service en lloc d‚Äôanar directe a Eloquent.

üìÑ `app/Http/Controllers/EquipController.php`

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreEquipRequest;
use App\Http\Requests\UpdateEquipRequest;
use App\Models\Equip;
use App\Models\Estadi;
use App\Services\EquipService;

class EquipController extends Controller
{
    public function __construct(private EquipService $servei) {}

    // GET /equips
    public function index() {
        $equips = $this->servei->llistar();
        return view('equips.index', compact('equips'));
    }

    // GET /equips/create
    public function create() {
        $estadis = Estadi::all();
        return view('equips.create', compact('estadis'));
    }

    // POST /equips
    public function store(StoreEquipRequest $request) {
        $this->servei->guardar($request->validated());
        return redirect()->route('equips.index');
    }

    // GET /equips/{equip}
    public function show(Equip $equip) {
        return view('equips.show', compact('equip'));
    }

    // GET /equips/{equip}/edit
    public function edit(Equip $equip) {
        return view('equips.edit', compact('equip'));
    }

    // PUT /equips/{equip}
    public function update(UpdateEquipRequest $request, Equip $equip) {
        $this->servei->actualitzar($equip->id, $request->validated());
        return redirect()->route('equips.index');
    }

    // DELETE /equips/{equip}
    public function destroy(Equip $equip) {
        $this->servei->eliminar($equip->id);
        return redirect()->route('equips.index');
    }
}
```

Ara el flux complet d‚Äôun CRUD d‚Äôequip √©s:

```text
[HTTP] ‚Üí EquipController
            ‚Üì
       EquipService
            ‚Üì
   BaseRepository (interface)
            ‚Üì
     EquipRepository (Eloquent)
            ‚Üì
        Model Equip
            ‚Üì
        Base de dades
```

---

### 5.2. Resum curt per a l‚Äôalumnat

- **Interface `BaseRepository`** 
  Contracte amb els m√®todes b√†sics: `getAll`, `find`, `create`, `update`, `delete`.

- **`EquipRepository`** 
  Implementa aquest contracte per al model `Equip` usant Eloquent.

- **`AppServiceProvider`**
  Registra que `BaseRepository` correspon a `EquipRepository`.

- **`EquipService`**
  Cont√© la l√≤gica d‚Äôequips i utilitza el repositori.

- **`EquipController`**
  Rep la petici√≥ HTTP, parla amb el service i retorna vistes.

Aix√≠ aconseguim controladors m√©s nets i un projecte que pot cr√©ixer millor, amb les responsabilitats ben separades.
