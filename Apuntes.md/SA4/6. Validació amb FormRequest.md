# 6. ğŸ§ª ValidaciÃ³ amb FormRequest

En aquesta part veurem com validar les dades dels **equips** de manera neta i reutilitzable mitjanÃ§ant els **FormRequest** de Laravel.

En lloc de fer la validaciÃ³ directament dins del controlador, la traurem a classes separades:

- `StoreEquipRequest` â†’ per a **crear** un equip.
- `UpdateEquipRequest` â†’ per a **actualitzar** un equip.

---

## 6.1. QuÃ¨ Ã©s la validaciÃ³ i per quÃ¨ usar FormRequest?

Quan lâ€™usuari envia un formulari (per exemple, â€œAfegir nou equipâ€), volem comprovar que:

- ha omplert tots els camps obligatoris,
- els valors tenen el format correcte (nÃºmeros, mÃ­nims, etc.),
- les claus forÃ nies existeixen (per exemple, `estadi_id` realment correspon a un estadi de la BBDD).

PodrÃ­em validar directament dins del controlador:

```php
$request->validate([
    'nom'       => 'required|min:3',
    'estadi_id' => 'required|integer|exists:estadis,id',
    'titols'    => 'required|integer|min:0',
]);
```

PerÃ² aixÃ² tÃ© inconvenients:

- El controlador es fa gran i brut.
- Si necessitem la mateixa validaciÃ³ en diversos llocs, repetim codi.
- Costa mÃ©s de provar i de mantindre.

ğŸ‘‰ SoluciÃ³: crear **FormRequest**, que sÃ³n classes dedicades a la validaciÃ³.

Avantatges:

- Separem validaciÃ³ del controlador.
- El codi Ã©s mÃ©s llegible.
- Podem reutilitzar els mateixos **rules** i personalitzar missatges.

---

## 6.2. Crear els FormRequest

Com que estem treballant amb el `Makefile`, en lloc de `./vendor/bin/sail` usarem:

```bash
make artisan CMD="make:request StoreEquipRequest"
make artisan CMD="make:request UpdateEquipRequest"
```

AixÃ² ens crearÃ  dos fitxers a:

- `app/Http/Requests/StoreEquipRequest.php`
- `app/Http/Requests/UpdateEquipRequest.php`

DesprÃ©s els editem amb el contingut segÃ¼ent.

---

## 6.3. `StoreEquipRequest`: validaciÃ³ en crear un equip

ğŸ“„ `app/Http/Requests/StoreEquipRequest.php`

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreEquipRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     * De moment deixem sempre true.
     */
    public function authorize(): bool
    {
        return true;
    }

    /**
     * Regles de validaciÃ³ per a crear un nou equip.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'nom'       => 'required|min:3',
            'estadi_id' => 'required|integer|exists:estadis,id',
            'titols'    => 'required|integer|min:0',
        ];
    }
}
```

TraducciÃ³ de les regles:

- `required` â†’ el camp Ã©s obligatori.
- `min:3` â†’ com a mÃ­nim 3 carÃ cters.
- `integer` â†’ ha de ser un enter.
- `exists:estadis,id` â†’ ha dâ€™existir una fila a la taula `estadis` amb aquest `id`.
- `min:0` â†’ no pot ser negatiu.

---

## 6.4. `UpdateEquipRequest`: validaciÃ³ en actualitzar un equip

ğŸ“„ `app/Http/Requests/UpdateEquipRequest.php`

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class UpdateEquipRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }

    /**
     * Regles de validaciÃ³ per a actualitzar un equip.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'nom'       => 'required|min:3',
            'estadi_id' => 'required|integer|exists:estadis,id',
            'titols'    => 'required|integer|min:0',
        ];
    }
}
```

En aquest cas, les regles sÃ³n les mateixes que per a crear. 
(En un projecte real, de vegades `store` i `update` tenen regles diferents, perÃ² per a la prÃ ctica, aixÃ­ Ã©s suficient.)

---

## 6.5. Usar els FormRequest al `EquipController`

Ja tens el controlador preparat per usar-los, nomÃ©s cal assegurar-se que la signatura dels mÃ¨todes Ã©s aixÃ­:

ğŸ“„ `app/Http/Controllers/EquipController.php` (fragments)

```php
use App\Http\Requests\StoreEquipRequest;
use App\Http\Requests\UpdateEquipRequest;
use App\Services\EquipService;
use App\Models\Estadi;
use App\Models\Equip;

class EquipController extends Controller
{
    public function __construct(private EquipService $servei) {}

    // POST /equips
    public function store(StoreEquipRequest $request)
    {
        // Si arribes acÃ­, la validaciÃ³ ja ha passat correctament
        $this->servei->guardar($request->validated());

        return redirect()->route('equips.index')
            ->with('success', 'Equip creat correctament!');
    }

    // PUT /equips/{equip}
    public function update(UpdateEquipRequest $request, Equip $equip)
    {
        $this->servei->actualitzar($equip->id, $request->validated());

        return redirect()->route('equips.index')
            ->with('success', 'Equip actualitzat correctament!');
    }
}
```

Coses importants:

- El tipus del parÃ metre Ã©s `StoreEquipRequest` o `UpdateEquipRequest` (no `Request`).
- Laravel:
  - valida automÃ ticament segons les regles del FormRequest,
  - si hi ha errors â†’ redirigeix de tornada al formulari anterior,
  - envia a la vista:
    - la variable `$errors`,
    - i els valors antics amb `old()`.

---

## 6.6. Mostrar errors en el formulari (vista Blade)

Ja ho tens muntat a `equips/create.blade.php`, perÃ² ho remarquem per a que es veja clar.

ğŸ“„ `resources/views/equips/create.blade.php` (fragments)

```blade
@extends('layouts.app')
@section('title', 'Afegir nou equip')

@section('content')
<h1 class="text-2xl font-bold mb-4">Afegir nou equip</h1>

@if ($errors->any())
  <div class="bg-red-100 text-red-700 p-2 mb-4">
    <ul>
      @foreach ($errors->all() as $error)
        <li>{{ $error }}</li>
      @endforeach
    </ul>
  </div>
@endif

<form action="{{ route('equips.store') }}" method="POST" class="space-y-4">
  @csrf
  <div>
    <label for="nom" class="block font-bold">Nom:</label>
    <input
      type="text"
      name="nom"
      id="nom"
      value="{{ old('nom') }}"
      class="border p-2 w-full"
    >
  </div>

  <div>
    <label for="estadi_id" class="block font-bold">Estadi:</label>
    <select name="estadi_id" id="estadi_id" class="border p-2 w-full">
      @foreach ($estadis as $estadi)
        <option value="{{ $estadi->id }}"
          {{ old('estadi_id') == $estadi->id ? 'selected' : '' }}>
          {{ $estadi->nom }}
        </option>
      @endforeach
    </select>
  </div>

  <div>
    <label for="titols" class="block font-bold">TÃ­tols:</label>
    <input
      type="number"
      name="titols"
      id="titols"
      value="{{ old('titols') }}"
      class="border p-2 w-full"
    >
  </div>

  <button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded">
    Afegir
  </button>
</form>
@endsection
```

Punts clau per a lâ€™alumnat:

- `$errors->any()` comprova si hi ha errors de validaciÃ³.
- `$errors->all()` llista tots els missatges.
- `old('camp')` recupera el valor que havia escrit lâ€™usuari abans de lâ€™error (aixÃ­ no ho ha de tornar a posar tot).

El mateix patrÃ³ es pot repetir a `equips/edit.blade.php`.

---

## 6.7. Resum de lâ€™apartat 6

1. Hem creat dues classes de validaciÃ³:
   - `StoreEquipRequest` â†’ per al **create**.
   - `UpdateEquipRequest` â†’ per al **update**.

2. Hem definit les **regles**:
   - `nom` obligatori, mÃ­nim 3 carÃ cters.
   - `estadi_id` ha dâ€™existir a `estadis`.
   - `titols` enter i mÃ­nim 0.

3. Hem canviat el `EquipController` perquÃ¨ use aquests FormRequest:
   - `store(StoreEquipRequest $request)`
   - `update(UpdateEquipRequest $request, Equip $equip)`

4. Hem vist com mostrar els errors a la vista amb `$errors` i recuperar valors amb `old()`.

A partir dâ€™ara, qualsevol error de validaciÃ³:

- redirigirÃ  automÃ ticament al formulari,
- mostrarÃ  els missatges dâ€™error,
- i conservarÃ  els valors que havia introduÃ¯t lâ€™usuari.
